{"name":"novcat","tagline":"","body":"## Scheme 学习笔记 v0.1 \r\n\r\n* 7/16/2013  更新第一版\r\n\r\n*****\r\n\r\n\r\n*    **注释**：\r\n    *    单行注释： ; XXXXXXXXX    ;; XXXX 会输出到Doxygen的文档中  #！也可以注释 \r\n    *    多行注释： #| XXXXXXXXX |#（sx中 )　（scheme中是 #！ ！#）\r\n*    **语言块**：  （XXX）  用小括号括起来.当然也可以使用[ ] 或者 {} 来替换小括号，但注意匹配。\r\n\r\n*    **变量**：\r\n    *    变量定义：    (#define  x  10) \r\n    *    变量赋值：    (set! x 100) \r\n    *    变量没有类型： \r\n        *    boolean型：  #t 和 #f 。 操作符: not 对于非boolean型的变量， (not  xxxx)  永远返回 #f ， 换句话说，XXXX永远被当做#t\r\n        *    number型：分为四种 \r\n            *    整型  （#define  x 10） \r\n            *    浮点数 (#define x 10.77777) \r\n            *    复数 (#define x 2+10i) \r\n            *    分数 (#define x  222/7 )  \r\n            >    **进制表示： #b(二进制)  #o（八进制）  #d（十进制，可忽略） #x（十六进制） 如： #b1010**\r\n            >    number? 可用来判定变量是否为number类型\r\n\r\n        *    char型： Scheme 中的字符都以#\\开头 . 一般分为2类：\r\n            1.普通字符： #\\c => 字母c  ， #\\A => A\r\n            2.特殊字符： 所谓特殊字符就是无法可视化的表现出来的字符，需要用一个英文单词来描述。如果空格（#\\space），换行（#\\newline），tab（#\\tab)\r\n\r\n                >    另外，字符也可以使用ascii码来表示，#\\NN, NN代表其ascii码，如#\\x20(16进制)表示#\\space\r\n            \r\n            *    字符的操作：\r\n                  ``` \r\n                    (define c #\\c)  ; 定义\r\n                    (char?  c)  => #t  ;  判定是否是字符\r\n                    ; 比较大小    \r\n                    (char=? #\\a #\\a)  => #t\r\n                    (char<? #\\a #\\b)  => #t\r\n                    (char>=? #\\a #\\b) => #f\r\n                    ；忽略大小写比较大小                    \r\n(char-ci=? #\\a #\\A) => #t\r\n(char-ci<? #\\a #\\B) => #t\r\n                    ; 大小写转换\r\n(char-downcase #\\A) => #\\a\r\n(char-upcase #\\a)   => #\\A  ```\r\n    \r\n        *    symbol型： 上述类型都属于自求值类型，所谓自求值类型是当你引用它时候，它返回的是自身的值。简单理解就是你在控制台输入某个变量，控制台会返回相应的值。\r\n而symbol型只是一种标识符，通常用来做枚举。\r\n\r\n            *    以'开头的  'xy => xy\r\n            *    以quote开头的 （两者等价，表示引用过的部分不计算)   （quote xy)  => xy\r\n        \r\n            *    symbol类型的操作：\r\n\r\n                ```     \r\n                    (symbol? 'xyz)  => #t ；判定是否是symbol类型\r\n                    (eqv? 'AAA 'aaa)  => #f  ; 比较\r\n                    (string->symbol \"aaa\") => aaa ; string转符号 \r\n                    ; symbol类型做枚举的例子\r\n                    (define (my-fun type)\r\n                           (case  type\r\n                                ((create\r\n                                    ; do something\r\n                              )    \r\n                     (my-fun ‘create)    ``` \r\n\r\n                     >    symbol是区分大小写的\r\n\r\n        *    复合类型： \r\n            *    string: 相关操作(字符串出现引号要用反斜杠转义） \r\n                *    (string-length x) \r\n                *    (string-set!  x index #\\p)  更改x index处的字符为p \r\n                *    (string-ref  x  3)  获取x下标为3的字符索引 \r\n        *    pair：点对 \r\n                *    使用 cons来定义：(define x (cons 1 2)) \r\n                *    第一个元素称为car，第二个元素称为cdr \r\n                *    (car x)   (cdr x) \r\n                *    (set-car! x 2)  (set-cdr! x 5) 更改元素\r\n        *    list：列表 \r\n                *    (define x (list 1 2 3 4)) \r\n                *    (define x (make-list 5 6)   x为5个6的列表 \r\n                *    (list-ref x 5) 取列表第五项 \r\n                *    (list-set! x 5 1) 设置列表第五项 \r\n                *    list的本质就是pair，可以使用car,cdr等操作\r\n        *    vector : 向量。和列表很像，但是比列表更节省空间 \r\n                *    (define x (vector 1 2 3 4))  或者  ( define x #(1 2 3 4) ) \r\n                *    vector-ref  vector-set! vector-length 和 list一样\r\n*    **比较**\r\n    * eq?    表示两个参数指向同一对象 \r\n    * eqv?  和eq? 相同 \r\n    * equals?  两个对象具有相同的数据结构并且内容相同\r\n\r\n*    **数学运算**\r\n    *    max, min, abs, expt （乘方）\r\n\r\n    ``` \r\n    (max 1 3 4 5)  => 5\r\n    (min 1 2 4 3)  => 1\r\n    (abs -1) => 1\r\n    ```\r\n\r\n*    **自定义操作符（函数）**\r\n    *    (define fun  (lambda ( arg1 arg2 ...)  process ) ) \r\n    *    简化版 (define (fun (arg1 arg2)  process)) \r\n    *    procedure?  判断是否为过程\r\n\r\n*    **流程控制**\r\n    *    (begin  xxxxx )  语句块 \r\n    *    (if  cond  xxxx  xxxx2)\r\n\r\n*    **let相关用法**：\r\n   define定义的变量是全局的，使用let可以定义局部的变量：\r\n   ```\r\n    (let \r\n        (\r\n            (x  1)\r\n            (y  1)    ; 定义的局部变量\r\n        )\r\n        (.....)    ; 中间的过程\r\n     )\r\n    ```\r\n\r\n*    **object**\r\n    *    定义一个类有两种方式：\r\n        *    不继承：(define (opt) (object body)) \r\n        *    继承： (define (opt) (inherit parent-class body))\r\n    >    换句话说，使用 object 运算或者 inherit运算可以产生一个新对象。\r\n\r\n    *    body中的成员： \r\n        *    （private member-variable value） 定义私有成员变量 \r\n        *    （private (method arg-list)） 定义私有成员函数 \r\n        *    （public member-variable value） 定义公有成员变量 \r\n        *    （public (method arg-list)） 定义公有成员函数 \r\n        *    （public/mutable member-variable value）表示该成员可以被覆盖 \r\n        *    （public/mutable (method arg-list)） 表示该成员函数可以被覆盖 \r\n        *    （public/override member-variable value）inherit中使用，表示该成员可被覆盖 \r\n        *    （public/override (method arg-list)） inherit中使用表示该成员函数被覆盖\r\n        *    this代表object本身，是一个特殊的符号。 \r\n\r\n    *    构造对象，直接调用 object 或者 inherit 即可。 \r\n    *    对象方法的调用： \r\n        *    （send x method arg-list）调用本类的方法 \r\n        *    （send/super x method arg-list) 调用父类的方法\r\n    *    对象成员的获取与修改： \r\n        *    （get x variable）=> 获取 \r\n        *    (object-set! object member value) => 修改\r\n    *    inspect函数：修改类的成员却不产生新类（相当于匿名类）。使用方法： (inspect object statements ) → object \r\n>    statements是用（）扩起来的一段语句，可以在这里重新定义覆盖object里的方法。\r\n\r\n    *    object-members 返回所有public函数的列表。 (object-members object) → list \r\n    *    delete : 删除对象： \r\n        *    (object-delete! object ) 外部删除 \r\n        *    (object-delete! ) 内部删除\r\n    *    对象的引用： \r\n        *    平常的使用对象称之为强引用，如果你的引用符号存在，对象就一直存在。 \r\n        *    使用weak返回对象的弱引用，对对象不再持有。 \r\n            *    (weak object ) => 返回object的弱引用。 \r\n            *    (weak object function ) => function是一个回调函数，当object被销毁的时候function会被调用。\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}